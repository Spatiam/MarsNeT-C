.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bpv6::doc::pod3::bp 3"
.TH bpv6::doc::pod3::bp 3 "2020-09-24" "perl v5.16.3" "BP library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bp \- Bundle Protocol communications library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "bp.h"
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The bp library provides functions enabling application software to use
Bundle Protocol to send and receive information over a delay-tolerant
network.  It conforms to the Bundle Protocol specification as documented
in Internet \s-1RFC 5050.\s0
.IP "int bp_attach( )" 4
.IX Item "int bp_attach( )"
Attaches the application to \s-1BP\s0 functionality on the local computer.  Returns
0 on success, \-1 on any error.
.Sp
Note that all \s-1ION\s0 libraries and applications draw memory dynamically, as
needed, from a shared pool of \s-1ION\s0 working memory.  The size of the pool is
established when \s-1ION\s0 node functionality is initialized by \fIionadmin\fR\|(1).  This
is a precondition for initializing \s-1BP\s0 functionality by running \fIbpadmin\fR\|(1),
which in turn is required in order for \fIbp_attach()\fR to succeed.
.IP "Sdr bp_get_sdr( )" 4
.IX Item "Sdr bp_get_sdr( )"
Returns handle for the \s-1SDR\s0 data store used for \s-1BP,\s0 to enable creation and
interrogation of bundle payloads (application data units).
.IP "void bp_detach( )" 4
.IX Item "void bp_detach( )"
Terminates all access to \s-1BP\s0 functionality on the local computer.
.IP "int bp_open(char *eid, BpSAP *ionsapPtr)" 4
.IX Item "int bp_open(char *eid, BpSAP *ionsapPtr)"
Opens the application's access to the \s-1BP\s0 endpoint identified by \fIeid\fR,
so that the application can take delivery of bundles destined for the
indicated endpoint.  This \s-1SAP\s0 can also be used for sending bundles whose
source is the indicated endpoint; all bundles sent via this \s-1SAP\s0 will be
subject to immediate destruction upon transmission, i.e., no bundle
addresses will be returned by \fIbp_send()\fR for use in tracking,
suspending/resuming, or cancelling transmission of these bundles.  On
success, places a value in \fI*ionsapPtr\fR that can be supplied to future
bp function invocations and returns 0.  Returns \-1 on any error.
.IP "int bp_open_source(char *eid, BpSAP *ionsapPtr, detain)" 4
.IX Item "int bp_open_source(char *eid, BpSAP *ionsapPtr, detain)"
Opens the application's access to the \s-1BP\s0 endpoint identified by \fIeid\fR,
so that the application can send bundles whose source is the indicated
endpoint.  If and only if the value of \fIdetain\fR is non-zero, citing this
\&\s-1SAP\s0 in an invocation of \fIbp_send()\fR will cause the address of the newly
issued bundle to be returned for use in tracking, suspending/resuming, or
cancelling transmission of this bundle.  \fB\s-1USE THIS FEATURE WITH GREAT CARE:\s0\fR
such a bundle will continue to occupy storage resources until it is
explicitly released by an invocation of \fIbp_release()\fR or until its time to
live expires, so bundle detention increases the risk of resource exhaustion.
(If the value of \fIdetain\fR is zero, all bundles sent via this \s-1SAP\s0 will be
subject to immediate destruction upon transmission.)  On success, places a
value in \fI*ionsapPtr\fR that can be supplied to future bp function invocations
and returns 0.  Returns \-1 on any error.
.IP "int bp_send(BpSAP sap, char *destEid, char *reportToEid, int lifespan, int classOfService, BpCustodySwitch custodySwitch, unsigned char srrFlags, int ackRequested, BpAncillaryData *ancillaryData, Object adu, Object *newBundle)" 4
.IX Item "int bp_send(BpSAP sap, char *destEid, char *reportToEid, int lifespan, int classOfService, BpCustodySwitch custodySwitch, unsigned char srrFlags, int ackRequested, BpAncillaryData *ancillaryData, Object adu, Object *newBundle)"
Sends a bundle to the endpoint identified by \fIdestEid\fR, from the
source endpoint as provided to the \fIbp_open()\fR call that returned \fIsap\fR.
When \fIsap\fR is \s-1NULL,\s0 the transmitted bundle is anonymous, i.e., the source
of the bundle is not identified.  This is legal, but anonymous bundles cannot
be uniquely identified; custody transfer and status reporting therefore cannot
be requested for an anonymous bundle.
.Sp
\&\fIreportToEid\fR identifies the endpoint to which any status reports
pertaining to this bundle will be sent; if \s-1NULL,\s0 defaults to the
source endpoint.
.Sp
\&\fIlifespan\fR is the maximum number of seconds that the bundle can remain
in-transit (undelivered) in the network prior to automatic deletion.
.Sp
\&\fIclassOfService\fR is simply priority for now: \s-1BP_BULK_PRIORITY,
BP_STD_PRIORITY,\s0 or \s-1BP_EXPEDITED_PRIORITY. \s0 If class-of-service flags
are defined in a future version of Bundle Protocol, those flags would be
\&\s-1OR\s0'd with priority.
.Sp
\&\fIcustodySwitch\fR indicates whether or not custody transfer is requested for
this bundle and, if so, whether or not the source node itself is required
to be the initial custodian.  The valid values are SourceCustodyRequired,
SourceCustodyOptional, NoCustodyRequired.  Note that custody transfer is
possible only for bundles that are uniquely identified, so it cannot be
requested for bundles for which \s-1BP_MINIMUM_LATENCY\s0 is requested, since
\&\s-1BP_MINIMUM_LATENCY\s0 may result in the production of multiple identical
copies of the same bundle.  Similarly, custody transfer should never be
requested for a \*(L"loopback\*(R" bundle, i.e., one whose destination node is
the same as the source node: the received bundle will be identical to the
source bundle, both residing in the same node, so no custody acceptance
signal can be applied to the source bundle and the source bundle will
remain in storage until its \s-1TTL\s0 expires.
.Sp
\&\fIsrrFlags\fR, if non-zero, is the logical \s-1OR\s0 of the status reporting behaviors
requested for this bundle: \s-1BP_RECEIVED_RPT, BP_CUSTODY_RPT, BP_FORWARDED_RPT,
BP_DELIVERED_RPT, BP_DELETED_RPT.\s0
.Sp
\&\fIackRequested\fR is a Boolean parameter indicating whether or not the recipient
application should be notified that the source application requests some sort
of application-specific end-to-end acknowledgment upon receipt of the bundle.
.Sp
\&\fIancillaryData\fR, if not \s-1NULL,\s0 is used to populate the Extended Class Of
Service block for this bundle.  The block's \fIordinal\fR value is used to
provide fine-grained ordering within \*(L"expedited\*(R" traffic: ordinal values
from 0 (the default) to 254 (used to designate the most urgent traffic)
are valid, with 255 reserved for custody signals.  The value of the block's
\&\fIflags\fR is the logical \s-1OR\s0 of the applicable extended class-of-service flags:
.RS 4
.Sp
.RS 4
\&\s-1BP_MINIMUM_LATENCY\s0 designates the bundle as \*(L"critical\*(R" for the
purposes of Contact Graph Routing.
.Sp
\&\s-1BP_BEST_EFFORT\s0 signifies that non-reliable convergence-layer protocols, as
available, may be used to transmit the bundle.  Notably, the bundle may be
sent as \*(L"green\*(R" data rather than \*(L"red\*(R" data when issued via \s-1LTP.\s0
.Sp
\&\s-1BP_DATA_LABEL_PRESENT\s0 signifies whether or not the value of \fIdataLabel\fR
in \fIancillaryData\fR must be encoded into the \s-1ECOS\s0 block when the bundle is
transmitted.
.RE
.RE
.RS 4
.Sp
\&\fIadu\fR is the \*(L"application data unit\*(R" that will be conveyed as the payload
of the new bundle.  \fIadu\fR must be a \*(L"zero-copy object\*(R" (\s-1ZCO\s0).  To ensure
orderly access to transmission buffer space for all applications, \fIadu\fR
must be created by invoking \fIionCreateZco()\fR, which may be configured either
to block so long as insufficient \s-1ZCO\s0 storage space is available for creation
of the requested \s-1ZCO\s0 or to fail immediately if insufficient \s-1ZCO\s0 storage space
is available.
.Sp
The function returns 1 on success, 0 on user error, \-1 on any system
error.  If 0 is returned, then an invalid argument value was passed to
\&\fIbp_send()\fR; a message to this effect will have been written to the log file.
If 1 is returned, then either the destination of the bundle was
\&\*(L"dtn:none\*(R" (the bit bucket) or the \s-1ADU\s0 has been accepted and queued for
transmission in a bundle.  In the latter case, if and only if \fIsap\fR was
a reference to a BpSAP returned by an invocation of \fIbp_open_source()\fR that
had a non-zero value in the \fIdetain\fR parameter, then \fInewBundle\fR must be
non-NULL and the address of the newly created bundle within the \s-1ION\s0 database
is placed in \fInewBundle\fR.  This address can be used to track, suspend/resume,
or cancel transmission of the bundle.
.RE
.IP "int bp_track(Object bundle, Object trackingElt)" 4
.IX Item "int bp_track(Object bundle, Object trackingElt)"
Adds \fItrackingElt\fR to the list of \*(L"tracking\*(R" references in \fIbundle\fR.
\&\fItrackingElt\fR must be the address of an \s-1SDR\s0 list element \*(-- whose data is
the address of this same bundle \*(-- within some list of bundles that is
privately managed by the application.  Upon destruction of the bundle this
list element will automatically be deleted, thus removing the bundle from
the application's privately managed list of bundles.  This enables the
application to keep track of bundles that it is operating on without risk
of inadvertently de-referencing the address of a nonexistent bundle.
.IP "void bp_untrack(Object bundle, Object trackingElt)" 4
.IX Item "void bp_untrack(Object bundle, Object trackingElt)"
Removes \fItrackingElt\fR from the list of \*(L"tracking\*(R" references in \fIbundle\fR,
if it is in that list.  Does not delete \fItrackingElt\fR itself.
.IP "int bp_memo(Object bundle, unsigned int interval)" 4
.IX Item "int bp_memo(Object bundle, unsigned int interval)"
Implements custodial retransmission.  This function inserts a
\&\*(L"custody-acceptance due\*(R" event into the timeline.  The event causes the
indicated bundle to be re-forwarded if it is still in the database (i.e.,
it has not yet been accepted by another custodian) as of the time computed
by adding the indicated interval to the current time.
.IP "int bp_suspend(Object bundle)" 4
.IX Item "int bp_suspend(Object bundle)"
Suspends transmission of \fIbundle\fR.  Has no effect if bundle is \*(L"critical\*(R"
(i.e., has got extended class of service \s-1BP_MINIMUM_LATENCY\s0 flag set) or
if the bundle is already suspended.  Otherwise, reverses the enqueuing of
the bundle to its selected transmission outduct and places it in the
\&\*(L"limbo\*(R" queue until the suspension is lifted by calling bp_resume.  Returns
0 on success, \-1 on any error.
.IP "int bp_resume(Object bundle)" 4
.IX Item "int bp_resume(Object bundle)"
Terminates suspension of transmission of \fIbundle\fR.  Has no effect if
bundle is \*(L"critical\*(R" (i.e., has got extended class of service
\&\s-1BP_MINIMUM_LATENCY\s0 flag set) or is not suspended.  Otherwise, removes
the bundle from the \*(L"limbo\*(R" queue and queues it for route re-computation
and re-queuing.  Returns 0 on success, \-1 on any error.
.IP "int bp_cancel(Object bundle)" 4
.IX Item "int bp_cancel(Object bundle)"
Cancels transmission of \fIbundle\fR.  If the indicated bundle is currently
queued for forwarding, transmission, or retransmission, it is removed
from the relevant queue and destroyed exactly as if its Time To Live had
expired.  Returns 0 on success, \-1 on any error.
.IP "int bp_release(Object bundle)" 4
.IX Item "int bp_release(Object bundle)"
Releases a detained bundle for destruction when all retention constraints
have been removed.  After a detained bundle has been released, the application
can no longer track, suspend/resume, or cancel its transmission.  Returns 0
on success, \-1 on any error.
.IP "int bp_receive(BpSAP sap, BpDelivery *dlvBuffer, int timeoutSeconds)" 4
.IX Item "int bp_receive(BpSAP sap, BpDelivery *dlvBuffer, int timeoutSeconds)"
Receives a bundle, or reports on some failure of bundle reception activity.
.Sp
The \*(L"result\*(R" field of the dlvBuffer structure will be used to indicate the
outcome of the data reception activity.
.Sp
If at least one bundle destined for the endpoint for which this \s-1SAP\s0 is
opened has not yet been delivered to the \s-1SAP,\s0 then the payload of the
oldest such bundle will be returned in \fIdlvBuffer\fR\->\fIadu\fR and
\&\fIdlvBuffer\fR\->\fIresult\fR will be set to BpPayloadPresent.  If there is
no such bundle, \fIbp_receive()\fR blocks for up to \fItimeoutSeconds\fR while
waiting for one to arrive.
.Sp
If \fItimeoutSeconds\fR is \s-1BP_POLL \s0(i.e., zero) and no bundle is awaiting
delivery, or if \fItimeoutSeconds\fR is greater than zero but no bundle
arrives before \fItimeoutSeconds\fR have elapsed, then \fIdlvBuffer\fR\->\fIresult\fR
will be set to BpReceptionTimedOut.  If \fItimeoutSeconds\fR is \s-1BP_BLOCKING
\&\s0(i.e., \-1) then \fIbp_receive()\fR blocks until either a bundle arrives or the
function is interrupted by an invocation of \fIbp_interrupt()\fR.
.Sp
\&\fIdlvBuffer\fR\->\fIresult\fR will be set to BpReceptionInterrupted in the event
that the calling process received and handled some signal other than \s-1SIGALRM\s0
while waiting for a bundle.
.Sp
\&\fIdlvBuffer\fR\->\fIresult\fR will be set to BpEndpointStopped in the event
that the operation of the indicated endpoint has been terminated.
.Sp
The application data unit delivered in the data delivery structure, if
any, will be a \*(L"zero-copy object\*(R" reference.  Use zco reception functions
(see \fIzco\fR\|(3)) to read the content of the application data unit.
.Sp
Be sure to call \fIbp_release_delivery()\fR after every successful invocation of
\&\fIbp_receive()\fR.
.Sp
The function returns 0 on success, \-1 on any error.
.IP "void bp_interrupt(BpSAP sap)" 4
.IX Item "void bp_interrupt(BpSAP sap)"
Interrupts a \fIbp_receive()\fR invocation that is currently blocked.  This
function is designed to be called from a signal handler; for this purpose,
\&\fIsap\fR may need to be obtained from a static variable.
.IP "void bp_release_delivery(BpDelivery *dlvBuffer, int releaseAdu)" 4
.IX Item "void bp_release_delivery(BpDelivery *dlvBuffer, int releaseAdu)"
Releases resources allocated to the indicated delivery.  \fIreleaseAdu\fR is a
Boolean parameter: if non-zero, the \s-1ADU ZCO\s0 reference in \fIdlvBuffer\fR (if
any) is destroyed, causing the \s-1ZCO\s0 itself to be destroyed if no other
references to it remain.
.IP "void bp_close(BpSAP sap)" 4
.IX Item "void bp_close(BpSAP sap)"
Terminates the application's access to the \s-1BP\s0 endpoint identified by
the \fIeid\fR cited by the indicated service access point.  The application
relinquishes its ability to take delivery of bundles destined for the
indicated endpoint and to send bundles whose source is the indicated
endpoint.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbpadmin\fR\|(1), \fIlgsend\fR\|(1), \fIlgagent\fR\|(1), \fIbpextensions\fR\|(3), \fIbprc\fR\|(5), \fIlgfile\fR\|(5)
