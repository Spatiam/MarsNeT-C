.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ici::doc::pod3::zco 3"
.TH ici::doc::pod3::zco 3 "2020-09-15" "perl v5.16.3" "ICI library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
zco \- library for manipulating zero\-copy objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "zco.h"
\&
\&    typedef enum
\&    {
\&        ZcoInbound = 0,
\&        ZcoOutbound = 1,
\&        ZcoUnknown = 2
\&    } ZcoAcct;
\&
\&    typedef enum
\&    {
\&        ZcoFileSource = 1,
\&        ZcoBulkSource = 2,
\&        ZcoObjSource = 3,
\&        ZcoSdrSource = 4,
\&        ZcoZcoSource = 5
\&    } ZcoMedium;
\&
\&    typedef void (*ZcoCallback)(ZcoAcct);
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\*(L"Zero-copy objects\*(R" (ZCOs) are abstract data access representations
designed to minimize I/O in the encapsulation of application source
data within one or more layers of communication protocol structure.  ZCOs
are constructed within the heap space of an \s-1SDR\s0 to which implementations
of all layers of the stack must have access.  Each \s-1ZCO\s0 contains information
enabling access to the source data objects, together with (a) a linked list
of zero or more \*(L"extents\*(R" that reference portions of these source data
objects and (b) linked lists of protocol header and trailer capsules that
have been explicitly attached to the \s-1ZCO\s0 since its creation.  The
concatenation of the headers (in ascending stack sequence), source data
object extents, and trailers (in descending stack sequence) is what is to
be transmitted or has been received.
.PP
Each source data object may be either a file (identified by pathname
stored in a \*(L"file reference\*(R" object in \s-1SDR\s0 heap) or an item in mass
storage (identified by item number, with implementation-specific
semantics, stored in a \*(L"bulk reference\*(R" object in \s-1SDR\s0 heap) or an
object in \s-1SDR\s0 heap space (identified by heap address stored in an
\&\*(L"object reference\*(R" object in \s-1SDR\s0 heap) or an array of bytes in \s-1SDR\s0
heap space (identified by heap address).  Each protocol header or
trailer capsule indicates the length and the address (within \s-1SDR\s0
heap space) of a single protocol header or trailer at some layer
of the stack.  Note that the source data object for each \s-1ZCO\s0 extent
is specified indirectly, by reference to a content lien reference
structure that refers to a heap space object, mass storage item, or file;
the reference structures contain the actual locations of the source data
together with reference counts, enabling any number of \*(L"clones\*(R" of a
given \s-1ZCO\s0 extent to be constructed without consuming additional resources.
These reference counts ensure that the reference structures and the
source data items they refer to are deleted automatically when (and
only when) all \s-1ZCO\s0 extents that reference them have been deleted.
.PP
Note that the safety of shared access to a \s-1ZCO\s0 is protected by the
fact that the \s-1ZCO\s0 resides in \s-1SDR\s0 heap space and therefore cannot be modified
other than in the course of an \s-1SDR\s0 transaction, which serializes
access.  Moreover, extraction of data from a \s-1ZCO\s0 may entail the reading
of file-based source data extents, which may cause file progress to
be updated in one or more file reference objects in the \s-1SDR\s0 heap.  For
this reason, all \s-1ZCO \s0\*(L"transmit\*(R" and \*(L"receive\*(R" functions must be performed
within \s-1SDR\s0 transactions.
.PP
Note also that \s-1ZCO\s0 can more broadly be used as a general-purpose
reference counting system for non-volatile data objects, where a
need for such a system is identified.
.PP
The total volume of file system space, mass storage space, and \s-1SDR\s0 heap
space that may be occupied by inbound and (separately) outbound \s-1ZCO\s0 extents
are system configuration parameters that may be set by \s-1ZCO\s0 library
functions.  Those limits are enforced when extents are appended to ZCOs:
total inbound and outbound \s-1ZCO\s0 file space, mass storage, and \s-1SDR\s0 heap
occupancy are updated continuously as ZCOs are created and destroyed,
and the formation of a new extent is prohibited when the length of the
extent exceeds the difference between the applicable limit and the
corresponding current occupancy total.  Doing separate accounting for
inbound and outbound ZCOs enables inbound ZCOs to be formed (for data
reception purposes) even when the total current volume of outbound ZCOs
has reached its limit, and vice versa.
.IP "void zco_register_callback(ZcoCallback notify)" 4
.IX Item "void zco_register_callback(ZcoCallback notify)"
This function registers the \*(L"callback\*(R" function that the \s-1ZCO\s0 system will
invoke every time a \s-1ZCO\s0 is destroyed, making \s-1ZCO\s0 file, bulk, and/or heap space
available for the formation of new \s-1ZCO\s0 extents.  This mechanism can be
used, for example, to notify tasks that are waiting for \s-1ZCO\s0 space to be
made available so that they can resume some communication protocol
procedure.
.IP "void zco_unregister_callback( )" 4
.IX Item "void zco_unregister_callback( )"
This function simply unregisters the currently registered callback function
for \s-1ZCO\s0 destruction.
.IP "Object zco_create_file_ref(Sdr sdr, char *pathName, char *cleanupScript, ZcoAcct acct)" 4
.IX Item "Object zco_create_file_ref(Sdr sdr, char *pathName, char *cleanupScript, ZcoAcct acct)"
Creates and returns a new file reference object, which can be used as the
source data extent location for creating a \s-1ZCO\s0 whose source data object is
the file identified by \fIpathName\fR.  \fIcleanupScript\fR, if not \s-1NULL,\s0 is invoked
at the moment the last \s-1ZCO\s0 that cites this file reference is destroyed
[normally upon delivery either down to the \*(L"\s-1ZCO\s0 transition layer\*(R" of the
protocol stack or up to a ZCO-capable application].  A zero-length string
is interpreted as implicit direction to delete the referenced file when
the file reference object is destroyed.  Maximum length of \fIcleanupScript\fR
is 255.  \fIacct\fR must be ZcoInbound or ZcoOutbound, depending on whether
the first \s-1ZCO\s0 that will reference this object will be inbound or outbound.
Returns \s-1SDR\s0 location of file reference object on success, 0 on any
error.
.IP "Object zco_revise_file_ref(Sdr sdr, Object fileRef, char *pathName, char *cleanupScript)" 4
.IX Item "Object zco_revise_file_ref(Sdr sdr, Object fileRef, char *pathName, char *cleanupScript)"
Changes the \fIpathName\fR and \fIcleanupScript\fR of the indicated file
reference.  The new values of these fields are validated as for
\&\fIzco_create_file_ref()\fR.  Returns 0 on success, \-1 on any error.
.IP "char *zco_file_ref_path(Sdr sdr, Object fileRef, char *buffer, int buflen)" 4
.IX Item "char *zco_file_ref_path(Sdr sdr, Object fileRef, char *buffer, int buflen)"
Retrieves the pathName associated with \fIfileRef\fR and stores it in \fIbuffer\fR,
truncating it to fit (as indicated by \fIbuflen\fR) and NULL-terminating it.  On
success, returns \fIbuffer\fR; returns \s-1NULL\s0 on any error.
.IP "int zco_file_ref_xmit_eof(Sdr sdr, Object fileRef)" 4
.IX Item "int zco_file_ref_xmit_eof(Sdr sdr, Object fileRef)"
Returns 1 if the last octet of the referenced file (as determined at the
time the file reference object was created) has been read by \s-1ZCO\s0 via a
reader with file offset tracking turned on.  Otherwise returns zero.
.IP "void zco_destroy_file_ref(Sdr sdr, Object fileRef)" 4
.IX Item "void zco_destroy_file_ref(Sdr sdr, Object fileRef)"
If the file reference object residing at location \fIfileRef\fR within
the indicated Sdr is no longer in use (no longer referenced by any \s-1ZCO\s0),
destroys this file reference object immediately.  Otherwise, flags this
file reference object for destruction as soon as the last reference to
it is removed.
.IP "Object zco_create_bulk_ref(Sdr sdr, unsigned long item, vast length, ZcoAcct acct)" 4
.IX Item "Object zco_create_bulk_ref(Sdr sdr, unsigned long item, vast length, ZcoAcct acct)"
Creates and returns a new bulk reference object, which can be used as the
source data extent location for creating a \s-1ZCO\s0 whose source data object is
the mass storage item of length \fIlength\fR identified by \fIitem\fR (the semantics
of which are implementation-dependent).  Note that the referenced item is
automatically destroyed at the time that the last \s-1ZCO\s0 that cites this bulk
reference is destroyed (normally upon delivery either down to the \*(L"\s-1ZCO\s0
transition layer\*(R" of the protocol stack or up to a ZCO-capable application).
\&\fIacct\fR must be ZcoInbound or ZcoOutbound, depending on whether the first
\&\s-1ZCO\s0 that will reference this object will be inbound or outbound.  Returns
\&\s-1SDR\s0 location of bulk reference object on success, 0 on any error.
.IP "void zco_destroy_bulk_ref(Sdr sdr, Object bulkRef)" 4
.IX Item "void zco_destroy_bulk_ref(Sdr sdr, Object bulkRef)"
If the bulk reference object residing at location \fIbulkRef\fR within
the indicated Sdr is no longer in use (no longer referenced by any \s-1ZCO\s0),
destroys this bulk reference object immediately.  Otherwise, flags this
bulk reference object for destruction as soon as the last reference to
it is removed.
.IP "Object zco_create_obj_ref(Sdr sdr, Object object, vast length, ZcoAcct acct)" 4
.IX Item "Object zco_create_obj_ref(Sdr sdr, Object object, vast length, ZcoAcct acct)"
Creates and returns a new object reference object, which can be used as the
source data extent location for creating a \s-1ZCO\s0 whose source data object is
the \s-1SDR\s0 heap object of length \fIlength\fR identified by \fIobject\fR.  Note that
the referenced object is automatically freed at the time that the last \s-1ZCO\s0
that cites this object reference is destroyed (normally upon delivery either
down to the \*(L"\s-1ZCO\s0 transition layer\*(R" of the protocol stack or up to a
ZCO-capable application).  \fIacct\fR must be ZcoInbound or ZcoOutbound,
depending on whether the first \s-1ZCO\s0 that will reference this object will
be inbound or outbound.  Returns \s-1SDR\s0 location of object reference object
on success, 0 on any error.
.IP "void zco_destroy_obj_ref(Sdr sdr, Object objRef)" 4
.IX Item "void zco_destroy_obj_ref(Sdr sdr, Object objRef)"
If the object reference object residing at location \fIobjRef\fR within
the indicated Sdr is no longer in use (no longer referenced by any \s-1ZCO\s0),
destroys this object reference object immediately.  Otherwise, flags this
object reference object for destruction as soon as the last reference to
it is removed.
.IP "void zco_status(Sdr sdr)" 4
.IX Item "void zco_status(Sdr sdr)"
Uses the \s-1ION\s0 logging function to write a report of the current contents of
the \s-1ZCO\s0 space accounting database.
.IP "vast zco_get_file_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_file_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of file system space bytes occupied by ZCOs (inbound
or outbound) created in this Sdr.
.IP "void zco_set_max_file_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)" 4
.IX Item "void zco_set_max_file_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)"
Declares the total number of file system space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "vast zco_get_max_file_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_max_file_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of file system space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "int zco_enough_file_space(Sdr sdr, vast length, ZcoAcct acct)" 4
.IX Item "int zco_enough_file_space(Sdr sdr, vast length, ZcoAcct acct)"
Returns 1 if the total remaining file system space available for ZCOs (inbound
or outbound) in this Sdr is greater than \fIlength\fR.  Returns 0 otherwise.
.IP "vast zco_get_bulk_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_bulk_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of mass storage space bytes occupied by ZCOs (inbound
or outbound) created in this Sdr.
.IP "void zco_set_max_bulk_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)" 4
.IX Item "void zco_set_max_bulk_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)"
Declares the total number of mass storage space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "vast zco_get_max_bulk_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_max_bulk_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of mass storage space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "int zco_enough_bulk_space(Sdr sdr, vast length, ZcoAcct acct)" 4
.IX Item "int zco_enough_bulk_space(Sdr sdr, vast length, ZcoAcct acct)"
Returns 1 if the total remaining mass storage space available for ZCOs (inbound
or outbound) in this Sdr is greater than \fIlength\fR.  Returns 0 otherwise.
.IP "vast zco_get_heap_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_heap_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of \s-1SDR\s0 heap space bytes occupied by ZCOs (inbound or
outbound) created in this Sdr.
.IP "void zco_set_max_heap_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)" 4
.IX Item "void zco_set_max_heap_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)"
Declares the total number of \s-1SDR\s0 heap space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "vast zco_get_max_heap_occupancy(Sdr sdr, ZcoAcct acct)" 4
.IX Item "vast zco_get_max_heap_occupancy(Sdr sdr, ZcoAcct acct)"
Returns the total number of \s-1SDR\s0 heap space bytes that may be occupied by
ZCOs (inbound or outbound) created in this Sdr.
.IP "int zco_enough_heap_space(Sdr sdr, vast length, ZcoAcct acct)" 4
.IX Item "int zco_enough_heap_space(Sdr sdr, vast length, ZcoAcct acct)"
Returns 1 if the total remaining \s-1SDR\s0 heap space available for ZCOs (inbound or
outbound) in this Sdr is greater than \fIlength\fR.  Returns 0 otherwise.
.IP "int zco_extent_too_large(Sdr sdr, ZcoMedium source, vast length, ZcoAcct acct)" 4
.IX Item "int zco_extent_too_large(Sdr sdr, ZcoMedium source, vast length, ZcoAcct acct)"
Returns 1 if the total remaining space available for ZCOs (inbound or outbound)
is \s-1NOT\s0 enough to contain a new extent of the indicated length in the indicated
source medium.  Returns 0 otherwise.
.IP "int zco_get_aggregate_length(Sdr sdr, Object location, vast offset, vast length, vast *fileSpaceOccupied, vast *bulkSpaceOccupied, vast *heapSpaceOccupied)" 4
.IX Item "int zco_get_aggregate_length(Sdr sdr, Object location, vast offset, vast length, vast *fileSpaceOccupied, vast *bulkSpaceOccupied, vast *heapSpaceOccupied)"
Populates \fI*fileSpaceOccupied\fR, \fI*bulkSpaceOccupied\fR, and
\&\fI*heapSpaceOccupied\fR with the total number of \s-1ZCO\s0 space bytes occupied by
the extents of the zco at \fIlocation\fR, from \fIoffset\fR to \fIoffset + length\fR.
If \fIoffset\fR isn't the start of an extent or \fIoffset + length\fR isn't the
end of an extent, returns \-1 in all three fields.
.IP "Object zco_create(Sdr sdr, ZcoMedium firstExtentSourceMedium, Object firstExtentLocation, vast firstExtentOffset, vast firstExtentLength, ZcoAcct acct)" 4
.IX Item "Object zco_create(Sdr sdr, ZcoMedium firstExtentSourceMedium, Object firstExtentLocation, vast firstExtentOffset, vast firstExtentLength, ZcoAcct acct)"
Creates a new inbound or outbound \s-1ZCO.  \s0\fIfirstExtentLocation\fR and
\&\fIfirstExtentLength\fR must either both be zero (indicating that
\&\fIzco_append_extent()\fR will be used to insert the first source data extent
later) or else both be non-zero.  If \fIfirstExtentLocation\fR is non-zero,
then (a) \fIfirstExtentLocation\fR must be the \s-1SDR\s0 location of a file
reference object, bulk reference object, object reference object, \s-1SDR\s0 heap
object, or \s-1ZCO,\s0 depending on the value of \fIfirstExtentSourceMedium\fR, and
(b) \fIfirstExtentOffset\fR indicates how many leading bytes of the source
data object should be skipped over when adding the initial source data
extent to the new \s-1ZCO.  A\s0 negative value for
\&\fIfirstExtentLength\fR indicates that the extent is already known not to be
too large for the available \s-1ZCO\s0 space, and the actual length of the extent
is the additive inverse of this value.  On success, returns the \s-1SDR\s0 location
of the new \s-1ZCO. \s0 Returns 0 if there is insufficient \s-1ZCO\s0 space for creation
of the new \s-1ZCO\s0; returns ((Object) \-1) on any error.
.IP "int zco_append_extent(Sdr sdr, Object zco, ZcoMedium sourceMedium, Object location, vast offset, vast length)" 4
.IX Item "int zco_append_extent(Sdr sdr, Object zco, ZcoMedium sourceMedium, Object location, vast offset, vast length)"
Appends the indicated source data extent to the indicated \s-1ZCO,\s0 as described
for \fIzco_create()\fR.  Both the \fIlocation\fR and \fIlength\fR of the source data
must be non-zero.  A negative value for \fIlength\fR indicates that the extent
is already known not to be too large for the available \s-1ZCO\s0 space, and the
actual length of the extent is the additive inverse of this value.  For
constraints on the value of \fIlocation\fR, see \fIzco_create()\fR.  Returns
\&\fIlength\fR on success, 0 if there is insufficient \s-1ZCO\s0 space for creation of
the new source data extent, \-1 on any error.
.IP "int zco_prepend_header(Sdr sdr, Object zco, char *header, vast length)" 4
.IX Item "int zco_prepend_header(Sdr sdr, Object zco, char *header, vast length)"
.PD 0
.IP "int zco_append_trailer(Sdr sdr, Object zco, char *trailer, vast length)" 4
.IX Item "int zco_append_trailer(Sdr sdr, Object zco, char *trailer, vast length)"
.IP "void zco_discard_first_header(Sdr sdr, Object zco)" 4
.IX Item "void zco_discard_first_header(Sdr sdr, Object zco)"
.IP "void zco_discard_last_trailer(Sdr sdr, Object zco)" 4
.IX Item "void zco_discard_last_trailer(Sdr sdr, Object zco)"
.PD
These functions attach and remove the \s-1ZCO\s0's headers and trailers.  \fIheader\fR
and \fItrailer\fR are assumed to be arrays of octets, not necessarily text.  
Attaching a header or trailer causes it to be written to the \s-1SDR. \s0 The
prepend and append functions return 0 on success, \-1 on any error.
.IP "Object zco_header_text(Sdr sdr, Object zco, int skip, vast *length)" 4
.IX Item "Object zco_header_text(Sdr sdr, Object zco, int skip, vast *length)"
Skips over the first \fIskip\fR headers of \fIzco\fR and returns the address of
the text of the next header, placing the length of the header's text in
\&\fI*length\fR.  Returns 0 on any error.
.IP "Object zco_trailer_text(Sdr sdr, Object zco, int skip, vast *length)" 4
.IX Item "Object zco_trailer_text(Sdr sdr, Object zco, int skip, vast *length)"
Skips over the first \fIskip\fR trailers of \fIzco\fR and returns the address of
the text of the next trailer, placing the length of the trailer's text in
\&\fI*length\fR.  Returns 0 on any error.
.IP "void zco_destroy(Sdr sdr, Object zco)" 4
.IX Item "void zco_destroy(Sdr sdr, Object zco)"
Destroys the indicated Zco.  This reduces the reference counts for all
files and \s-1SDR\s0 objects referenced in the \s-1ZCO\s0's extents, resulting in the
freeing of \s-1SDR\s0 objects and (optionally) the deletion of files as those
reference count drop to zero.
.IP "void zco_bond(Sdr sdr, Object zco)" 4
.IX Item "void zco_bond(Sdr sdr, Object zco)"
Converts all headers and trailers of the indicated Zco to source data extents.
Use this function to ensure that known header and trailer data are included
when the \s-1ZCO\s0 is cloned.
.IP "int zco_revise(Sdr sdr, Object zco, vast offset, char *buffer, vast length)" 4
.IX Item "int zco_revise(Sdr sdr, Object zco, vast offset, char *buffer, vast length)"
Writes the contents of \fIbuffer\fR, for length \fIlength\fR, into \fIzco\fR at offset
\&\fIoffset\fR.  Returns 0 on success, \-1 on any error.
.IP "Object zco_clone(Sdr sdr, Object zco, vast offset, vast length)" 4
.IX Item "Object zco_clone(Sdr sdr, Object zco, vast offset, vast length)"
Creates a new \s-1ZCO\s0 whose source data is a copy of a subset of the source
data of the referenced \s-1ZCO. \s0 This procedure is required whenever it is
necessary to process the \s-1ZCO\s0's source data in multiple different ways, for
different purposes, and therefore the \s-1ZCO\s0 must be in multiple states at the
same time.  Portions of the source data extents of the original \s-1ZCO\s0 are
copied as necessary, but no header or trailer capsules are copied.  Returns
\&\s-1SDR\s0 location of the new \s-1ZCO\s0 on success, (Object) \-1 on any error.
.IP "vast zco_clone_source_data(Sdr sdr, Object toZco, Object fromZco, vast offset, vast length)" 4
.IX Item "vast zco_clone_source_data(Sdr sdr, Object toZco, Object fromZco, vast offset, vast length)"
Appends to \fItoZco\fR a copy of a subset of the source data of \fIfromZCO\fR.
Portions of the source data extents of \fIfromZCO\fR are copied as necessary.
Returns total data length cloned, or \-1 on any error.
.IP "vast zco_length(Sdr sdr, Object zco)" 4
.IX Item "vast zco_length(Sdr sdr, Object zco)"
Returns length of entire \s-1ZCO,\s0 including all headers and trailers and
all source data extents.  This is the size of the object that would be
formed by concatenating the text of all headers, trailers, and source
data extents into a single serialized object.
.IP "vast zco_source_data_length(Sdr sdr, Object zco)" 4
.IX Item "vast zco_source_data_length(Sdr sdr, Object zco)"
Returns length of entire \s-1ZCO\s0 minus the lengths of all attached header and
trailer capsules.  This is the size of the object that would be formed by
concatenating the text of all source data extents (including those that
are presumed to contain header or trailer text attached elsewhere) into
a single serialized object.
.IP "ZcoAcct zco_acct(Sdr sdr, Object zco)" 4
.IX Item "ZcoAcct zco_acct(Sdr sdr, Object zco)"
Returns an indicator as to whether \fIzco\fR is inbound or outbound.
.IP "void zco_start_transmitting(Object zco, ZcoReader *reader)" 4
.IX Item "void zco_start_transmitting(Object zco, ZcoReader *reader)"
Used by underlying protocol layer to start extraction of an outbound \s-1ZCO\s0's
bytes (both from header and trailer capsules and from source data extents) for
\&\*(L"transmission\*(R" \*(-- i.e., the copying of bytes into a memory buffer for
delivery to some non-ZCO-aware protocol implementation.  Initializes
reading at the first byte of the total concatenated \s-1ZCO\s0 object.  Populates
\&\fIreader\fR, which is used to keep track of \*(L"transmission\*(R" progress via this
\&\s-1ZCO\s0 reference.
.Sp
Note that this function can be called multiple times to restart reading at
the start of the \s-1ZCO. \s0 Note also that multiple ZcoReader objects may be used
concurrently, by the same task or different tasks, to advance through the
\&\s-1ZCO\s0 independently.
.IP "void zco_track_file_offset(ZcoReader *reader)" 4
.IX Item "void zco_track_file_offset(ZcoReader *reader)"
Turns on file offset tracking for this reader.
.IP "vast zco_transmit(Sdr sdr, ZcoReader *reader, vast length, char *buffer)" 4
.IX Item "vast zco_transmit(Sdr sdr, ZcoReader *reader, vast length, char *buffer)"
Copies \fIlength\fR as-yet-uncopied bytes of the total concatenated \s-1ZCO
\&\s0(referenced by \fIreader\fR) into \fIbuffer\fR.  If \fIbuffer\fR is \s-1NULL,\s0 skips
over \fIlength\fR bytes without copying.  Returns the number of bytes copied
(or skipped) on success, 0 on any file access error, \-1 on any other error.
.IP "void zco_start_receiving(Object zco, ZcoReader *reader)" 4
.IX Item "void zco_start_receiving(Object zco, ZcoReader *reader)"
Used by overlying protocol layer to start extraction of an inbound \s-1ZCO\s0's
bytes for \*(L"reception\*(R" \*(-- i.e., the copying of bytes into a memory buffer
for delivery to a protocol header parser, to a protocol trailer parser,
or to the ultimate recipient (application).  Initializes reading of
headers, source data, and trailers at the first byte of the concatenated
\&\s-1ZCO\s0 objects.  Populates \fIreader\fR, which is used to keep track of \*(L"reception\*(R"
progress via this \s-1ZCO\s0 reference and is required.
.IP "vast zco_receive_headers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)" 4
.IX Item "vast zco_receive_headers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)"
Copies \fIlength\fR as-yet-uncopied bytes of presumptive protocol header text
from \s-1ZCO\s0 source data extents into \fIbuffer\fR.  If \fIbuffer\fR is \s-1NULL,\s0 skips
over \fIlength\fR bytes without copying.  Returns number of bytes copied (or
skipped) on success, 0 on any file access error, \-1 on any other error.
.IP "void zco_delimit_source(Sdr sdr, Object zco, vast offset, vast length)" 4
.IX Item "void zco_delimit_source(Sdr sdr, Object zco, vast offset, vast length)"
Sets the computed offset and length of actual source data in the \s-1ZCO,\s0
thereby implicitly establishing the total length of the \s-1ZCO\s0's concatenated
protocol headers as \fIoffset\fR and the location of the \s-1ZCO\s0's innermost
protocol trailer as the sum of \fIoffset\fR and \fIlength\fR.  Offset and length
are typically determined from the information carried in received presumptive
protocol header text.
.IP "vast zco_receive_source(Sdr sdr, ZcoReader *reader, vast length, char *buffer)" 4
.IX Item "vast zco_receive_source(Sdr sdr, ZcoReader *reader, vast length, char *buffer)"
Copies \fIlength\fR as-yet-uncopied bytes of source data from \s-1ZCO\s0 extents into
\&\fIbuffer\fR.  If \fIbuffer\fR is \s-1NULL,\s0 skips over \fIlength\fR bytes without
copying.  Returns number of bytes copied (or skipped) on success, 0 on any
file access error, \-1 on any other error.
.IP "vast zco_receive_trailers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)" 4
.IX Item "vast zco_receive_trailers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)"
Copies \fIlength\fR as-yet-uncopied bytes of trailer data from \s-1ZCO\s0 extents into
\&\fIbuffer\fR.  If \fIbuffer\fR is \s-1NULL,\s0 skips over \fIlength\fR bytes without copying.
Returns number of bytes copied (or skipped) on success, 0 on any file access
error, \-1 on any other error.
.IP "void zco_strip(Sdr sdr, Object zco)" 4
.IX Item "void zco_strip(Sdr sdr, Object zco)"
Deletes all source data extents that contain only header or trailer data and
adjusts the offsets and/or lengths of all remaining extents to exclude any
known header or trailer data.  This function is useful when handling a \s-1ZCO\s0
that was received from an underlying protocol layer rather than from an
overlying application or protocol layer; use it before starting the
transmission of the \s-1ZCO\s0 to another node or before enqueuing it for
reception by an overlying application or protocol layer.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIsdr\fR\|(3)
