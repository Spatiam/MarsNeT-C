.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ici::doc::pod3::lyst 3"
.TH ici::doc::pod3::lyst 3 "2020-09-24" "perl v5.16.3" "ICI library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
lyst \- library for manipulating generalized doubly linked lists
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "lyst.h"
\&
\&    typedef int  (*LystCompareFn)(void *s1, void *s2);
\&    typedef void (*LystCallback)(LystElt elt, void *userdata);
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \*(L"lyst\*(R" library uses two types of objects, \fILyst\fR objects
and \fILystElt\fR objects.  A Lyst knows how many elements it contains, 
its first and last elements, the memory manager used
to create/destroy the Lyst and its elements, and how the elements are
sorted.  A LystElt knows its content (normally a pointer to an item
in memory), what Lyst it belongs to, and the LystElts before and after
it in that Lyst.
.IP "Lyst lyst_create(void)" 4
.IX Item "Lyst lyst_create(void)"
Create and return a new Lyst object without any elements in it.
All operations performed on this Lyst will use the
allocation/deallocation functions of the default memory
manager \*(L"std\*(R" (see \fImemmgr\fR\|(3)).  Returns \s-1NULL\s0 on any failure.
.IP "Lyst lyst_create_using(unsigned memmgrId)" 4
.IX Item "Lyst lyst_create_using(unsigned memmgrId)"
Create and return a new Lyst object without any elements in it.
All operations performed on this Lyst will use the
allocation/deallocation functions of the specified
memory manager (see \fImemmgr\fR\|(3)).  Returns \s-1NULL\s0 on any failure.
.IP "void lyst_clear(Lyst list)" 4
.IX Item "void lyst_clear(Lyst list)"
Clear a Lyst, i.e. free all elements of \fIlist\fR, calling the Lyst's
deletion function if defined, but without destroying the Lyst itself.
.IP "void lyst_destroy(Lyst list)" 4
.IX Item "void lyst_destroy(Lyst list)"
Destroy a Lyst.  Will free all elements of \fIlist\fR, calling the Lyst's
deletion function if defined.
.IP "void lyst_compare_set(Lyst list, LystCompareFn compareFn)" 4
.IX Item "void lyst_compare_set(Lyst list, LystCompareFn compareFn)"
.PD 0
.IP "LystCompareFn lyst_compare_get(Lyst list)" 4
.IX Item "LystCompareFn lyst_compare_get(Lyst list)"
.PD
Set/get comparison function for specified Lyst.  Comparison 
functions are called with two Lyst element data
pointers, and must return a negative integer if first
is less than second, 0 if both are equal, and a positive integer
if first is greater than second (i.e., same return values as \fIstrcmp\fR\|(3)).
The comparison function is used by the
\&\fIlyst_insert()\fR, \fIlyst_search()\fR, \fIlyst_sort()\fR, and \fIlyst_sorted()\fR
functions.
.IP "void lyst_direction_set(Lyst list, LystSortDirection direction)" 4
.IX Item "void lyst_direction_set(Lyst list, LystSortDirection direction)"
Set sort direction (either \s-1LIST_SORT_ASCENDING\s0 or
\&\s-1LIST_SORT_DESCENDING\s0) for specified Lyst.  If no comparison
function is set, then this controls whether
new elements are added to the end or beginning (respectively) 
of the Lyst when \fIlyst_insert()\fR is called.
.IP "void lyst_delete_set(Lyst list, LystCallback deleteFn, void *userdata)" 4
.IX Item "void lyst_delete_set(Lyst list, LystCallback deleteFn, void *userdata)"
Set user deletion function for specified Lyst.  This
function is automatically called whenever an element of the Lyst is deleted,
to perform any user-required processing.  When automatically called,
the deletion function is passed two arguments: the element being deleted
and the \fIuserdata\fR pointer specified in the \fIlyst_delete_set()\fR call.
.IP "void lyst_insert_set(Lyst list, LystCallback insertFn, void *userdata)" 4
.IX Item "void lyst_insert_set(Lyst list, LystCallback insertFn, void *userdata)"
Set user insertion function for specified Lyst.  This
function is automatically called whenever a Lyst element is
inserted into the Lyst, to perform any user-required processing.
When automatically called, the insertion function is passed two arguments:
the element being inserted and the \fIuserdata\fR pointer specified in
the \fIlyst_insert_set()\fR call.
.IP "unsigned long lyst_length(Lyst list)" 4
.IX Item "unsigned long lyst_length(Lyst list)"
Return the number of elements in the Lyst.
.IP "LystElt lyst_insert(Lyst list, void *data)" 4
.IX Item "LystElt lyst_insert(Lyst list, void *data)"
Create a new element whose content is the pointer value \fIdata\fR
and insert it into the Lyst.  Uses the Lyst's comparison
function to select insertion point, if defined; otherwise
adds the new element at the beginning or end of the Lyst,
depending on the Lyst sort direction setting.  Returns a
pointer to the newly created element, or \s-1NULL\s0 on any failure.
.IP "LystElt lyst_insert_first(Lyst list, void *data)" 4
.IX Item "LystElt lyst_insert_first(Lyst list, void *data)"
.PD 0
.IP "LystElt lyst_insert_last(Lyst list, void *data)" 4
.IX Item "LystElt lyst_insert_last(Lyst list, void *data)"
.PD
Create a new element and insert it at the beginning/end
of the Lyst.  If these functions are used when inserting elements
into a Lyst with a defined comparison function, then the Lyst may
get out of order and future calls to \fIlyst_insert()\fR can put new elements 
in unpredictable locations.  Returns a pointer to
the newly created element, or \s-1NULL\s0 on any failure.
.IP "LystElt lyst_insert_before(LystElt element, void *data)" 4
.IX Item "LystElt lyst_insert_before(LystElt element, void *data)"
.PD 0
.IP "LystElt lyst_insert_after(LystElt element, void *data)" 4
.IX Item "LystElt lyst_insert_after(LystElt element, void *data)"
.PD
Create a new element and insert it before/after the
specified element.  If these functions are used when inserting
elements into a Lyst with a defined comparison function,
then the Lyst may get out
of order and future calls to \fIlyst_insert()\fR can put new
elements in unpredictable locations.  Returns a pointer
to the newly created element, or \s-1NULL\s0 on any failure.
.IP "void lyst_delete(LystElt element)" 4
.IX Item "void lyst_delete(LystElt element)"
Delete the specified element from its Lyst and deallocate its memory.  
Calls the user delete function if defined.
.IP "LystElt lyst_first(Lyst list)" 4
.IX Item "LystElt lyst_first(Lyst list)"
.PD 0
.IP "LystElt lyst_last(Lyst list)" 4
.IX Item "LystElt lyst_last(Lyst list)"
.PD
Return a pointer to the first/last element of a Lyst.
.IP "LystElt lyst_next(LystElt element)" 4
.IX Item "LystElt lyst_next(LystElt element)"
.PD 0
.IP "LystElt lyst_prev(LystElt element)" 4
.IX Item "LystElt lyst_prev(LystElt element)"
.PD
Return a pointer to the element following/preceding the specified element.
.IP "LystElt lyst_search(LystElt element, void *searchValue)" 4
.IX Item "LystElt lyst_search(LystElt element, void *searchValue)"
Find the first matching element in a Lyst starting with
the specified element.  Returns \s-1NULL\s0 if no matches are
found.  Uses the Lyst's comparison function if defined,
otherwise searches from the given element to the end of the Lyst.
.IP "Lyst lyst_lyst(LystElt element)" 4
.IX Item "Lyst lyst_lyst(LystElt element)"
Return the Lyst to which the specified element belongs.
.IP "void* lyst_data(LystElt element)" 4
.IX Item "void* lyst_data(LystElt element)"
.PD 0
.IP "void* lyst_data_set(LystElt element, void *data)" 4
.IX Item "void* lyst_data_set(LystElt element, void *data)"
.PD
Get/set the pointer value content of the specified Lyst element.  The
set routine returns the element's previous content, and the
delete function is \fInot\fR called.  If the \fIlyst_data_set()\fR
function is used on an element of a Lyst with a defined comparison
function, then the Lyst may get out of order and future calls to
\&\fIlyst_insert()\fR can put new elements in unpredictable locations.
.IP "void lyst_sort(Lyst list)" 4
.IX Item "void lyst_sort(Lyst list)"
Sort the Lyst based on the current comparison function
and sort direction.  A stable insertion sort is used
that is very fast when the elements are already in order.
.IP "int lyst_sorted(Lyst list)" 4
.IX Item "int lyst_sorted(Lyst list)"
Determine whether or not the Lyst is sorted based on
the current comparison function and sort direction.
.IP "void lyst_apply(Lyst list, LystCallback applyFn, void *userdata)" 4
.IX Item "void lyst_apply(Lyst list, LystCallback applyFn, void *userdata)"
Apply the function \fIapplyFn\fR automatically to each element
in the Lyst.  When automatically called, \fIapplyFn\fR is passed
two arguments: a pointer to an element, and the \fIuserdata\fR
argument specified in the call to \fIlyst_apply()\fR.  \fIapplyFn\fR
should not delete or reorder the elements in the Lyst.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fImemmgr\fR\|(3), \fIpsm\fR\|(3)
