.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "dgr::doc::pod3::dgr 3"
.TH dgr::doc::pod3::dgr 3 "2020-09-15" "perl v5.16.3" "DGR library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
dgr \- Datagram Retransmission system library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "dgr.h"
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1DGR\s0 library is an alternative implementation of a subset of \s-1LTP,\s0 intended
for use over \s-1UDP/IP\s0 in the Internet; unlike \s-1ION\s0's canonical \s-1LTP\s0 implementation
it includes a congestion control mechanism that interprets \s-1LTP\s0 block
transmission failure as an indication of network congestion (not data
corruption) and reduces data transmission rate in response.
.PP
As such, \s-1DGR\s0 differs from many reliable-UDP systems in two main ways:
.PP
.Vb 3
\&        It uses adaptive timeout interval computation techniques
\&        borrowed from TCP to try to avoid introducing congestion
\&        into the network.
\&
\&        It borrows the concurrent\-session model of transmission
\&        from LTP (and ultimately from CFDP), rather than waiting
\&        for one datagram to be acknowledged before sending the next,
\&        to improve bandwidth utilization.
.Ve
.PP
At this time \s-1DGR\s0 is interoperable with other implementations of \s-1LTP\s0 only when
each block it receives is transmitted in a single \s-1LTP\s0 data segment encapsulated
in a single \s-1UDP\s0 datagram.  More complex \s-1LTP\s0 behavior may be implemented in
the future.
.IP "int dgr_open(uvast ownEngineId, unsigned int clientSvcId, unsigned short ownPortNbr, unsigned int ownIpAddress, char *memmgrName, Dgr *dgr, DgrRC *rc)" 4
.IX Item "int dgr_open(uvast ownEngineId, unsigned int clientSvcId, unsigned short ownPortNbr, unsigned int ownIpAddress, char *memmgrName, Dgr *dgr, DgrRC *rc)"
Establishes the application's access to \s-1DGR\s0 communication service.
.Sp
\&\fIownEngineId\fR is the sending \s-1LTP\s0 engine \s-1ID\s0 that will characterize segments
issued by this \s-1DGR\s0 service access point.  In order to prevent erroneous system
behavior, never assign the same \s-1LTP\s0 engine \s-1ID\s0 to any two interoperating
\&\s-1DGR\s0 SAPs.
.Sp
\&\fIclientSvcId\fR identifies the \s-1LTP\s0 client service to which all \s-1LTP\s0 segments
issued by this \s-1DGR\s0 service access point will be directed.
.Sp
\&\fIownPortNbr\fR is the port number to use for \s-1DGR\s0 service.  If zero, a
system-assigned \s-1UDP\s0 port number is used.
.Sp
\&\fIownIpAddress\fR is the Internet address of the network interface to use for
\&\s-1DGR\s0 service.  If zero, this argument defaults to the address of the interface
identified by the local machine's host name.
.Sp
\&\fImemmgrName\fR is the name of the memory manager (see \fImemmgr\fR\|(3)) to use for
dynamic memory management in \s-1DGR. \s0 If \s-1NULL,\s0 defaults to the standard
system \fImalloc()\fR and \fIfree()\fR functions.
.Sp
\&\fIdgr\fR is the location in which to store the service access pointer that must
be supplied on subsequent \s-1DGR\s0 function invocations.
.Sp
\&\fIrc\fR is the location in which to store the \s-1DGR\s0 return code resulting from
the attempt to open this service access point (always DgrOpened).
.Sp
On any failure, returns \-1.  On success, returns zero.
.IP "void dgr_getsockname(Dgr dgr, unsigned short *portNbr, unsigned int *ipAddress)" 4
.IX Item "void dgr_getsockname(Dgr dgr, unsigned short *portNbr, unsigned int *ipAddress)"
States the port number and \s-1IP\s0 address of the \s-1UDP\s0 socket used for this \s-1DGR\s0
service access point.
.IP "void dgr_close(Dgr dgr)" 4
.IX Item "void dgr_close(Dgr dgr)"
Reverses \fIdgr_open()\fR, releasing resources where possible.
.IP "int dgr_send(Dgr dgr, unsigned short toPortNbr, unsigned int toIpAddress, int notificationFlags, char *content, int length, DgrRC *rc)" 4
.IX Item "int dgr_send(Dgr dgr, unsigned short toPortNbr, unsigned int toIpAddress, int notificationFlags, char *content, int length, DgrRC *rc)"
Sends the indicated content, of length as indicated, to the remote \s-1DGR\s0
service access point identified by \fItoPortNbr\fR and \fItoIpAddress\fR.  The
message will be retransmitted as necessary until either it is acknowledged or
\&\s-1DGR\s0 determines that it cannot be delivered.
.Sp
\&\fInotificationFlags\fR, if non-zero, is the logical \s-1OR\s0 of the notification
behaviors requested for this datagram.  Available behaviors are \s-1DGR_NOTE_FAILED
\&\s0(a notice of datagram delivery failure will issued if delivery of the
datagram fails) and \s-1DGR_NOTE_ACKED \s0(a notice of datagram delivery success
will be issued if delivery of the datagram succeeds).  Notices are issued
via \fIdgr_receive()\fR that is, the thread that calls \fIdgr_receive()\fR on this \s-1DGR\s0
service access point will receive these notices interspersed with inbound
datagram contents.
.Sp
\&\fIlength\fR of content must be greater than zero and may be as great
as 65535, but lengths greater than 8192 may not be supported by the local
underlying \s-1UDP\s0 implementation; to minimize the chance of data loss when
transmitting over the internet, length should not exceed 512.
.Sp
\&\fIrc\fR is the location in which to store the \s-1DGR\s0 return code resulting from
the attempt to send the content.
.Sp
On any failure, returns \-1 and sets \fI*rc\fR to DgrFailed.  On success, returns
zero.
.IP "int dgr_receive(Dgr dgr, unsigned short *fromPortNbr, unsigned int *fromIpAddress, char *content, int *length, int *errnbr, int timeoutSeconds, DgrRC *rc)" 4
.IX Item "int dgr_receive(Dgr dgr, unsigned short *fromPortNbr, unsigned int *fromIpAddress, char *content, int *length, int *errnbr, int timeoutSeconds, DgrRC *rc)"
Delivers the oldest undelivered \s-1DGR\s0 event queued for delivery.
.Sp
\&\s-1DGR\s0 events are of two type: (a) messages received from a remote \s-1DGR\s0
service access point and (b) notices of previously sent messages that
\&\s-1DGR\s0 has determined either have been or cannot be delivered, as requested
in the \fInotificationFlags\fR parameters provided to the \fIdgr_send()\fR calls
that sent those messages.
.Sp
In the former case, \fIdgr_receive()\fR will place the content of the inbound
message in \fIcontent\fR, its length in \fIlength\fR, and the \s-1IP\s0 address and port
number of the sender in \fIfromIpAddress\fR and \fIfromPortNbr\fR, and it will
set \fI*rc\fR to DgrDatagramReceived and return zero.
.Sp
In the latter case, \fIdgr_receive()\fR will place the content of the affected
\&\fBoutbound\fR message in \fIcontent\fR and its length in \fIlength\fR and return
zero.  If the event being reported is a delivery success, then
DgrDatagramAcknowledged will be placed in \fI*rc\fR.  Otherwise,
DgrDatagramNotAcknowledged will be placed in \fI*rc\fR and
the relevant errno (if any) will be placed in \fI*errnbr\fR.
.Sp
The \fIcontent\fR buffer should be at least 65535 bytes in length to enable
delivery of the content of the received or delivered/undeliverable message.
.Sp
\&\fItimeoutSeconds\fR controls blocking behavior.  If \fItimeoutSeconds\fR
is \s-1DGR_BLOCKING \s0(i.e., \-1), \fIdgr_receive()\fR will not return until (a) there
is either an inbound message to deliver or an outbound message delivery
result to report, or (b) the function is interrupted by means of
\&\fIdgr_interrupt()\fR.  If \fItimeoutSeconds\fR is \s-1DGR_POLL \s0(i.e., zero),
\&\fIdgr_receive()\fR returns immediately; if there is currently no
inbound message to deliver and no outbound message
delivery result to report, the function sets \fI*rc\fR to DgrTimedOut and
returns zero.
For any other positive value of \fItimeoutSeconds\fR, \fIdgr_receive()\fR returns
after the indicated number of seconds have lapsed (in which case the
returned value of \fI*rc\fR is DgrTimedOut), or when there is a message to deliver
or a delivery result to report, or when the function is interrupted
by means of \fIdgr_interrupt()\fR, whichever occurs first.  When the function
returns due to interruption by \fIdgr_interrupt()\fR, the value placed in \fI*rc\fR is
DgrInterrupted instead of DgrDatagramReceived.
.Sp
\&\fIrc\fR is the location in which to store the \s-1DGR\s0 return code resulting from
the attempt to receive content.
.Sp
On any I/O error or other unrecoverable system error, returns \-1.  Otherwise
always returns zero, placing DgrFailed in \fI*rc\fR and writing a failure message
in the event of an operating error.
.IP "void dgr_interrupt(Dgr dgr)" 4
.IX Item "void dgr_interrupt(Dgr dgr)"
Interrupts a \fIdgr_receive()\fR invocation that is currently blocked.  Designed 
to be called from a signal handler; for this purpose, \fIdgr\fR may need to
be obtained from a static variable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIltp\fR\|(3), \fIfile2dgr\fR\|(1), \fIdgr2file\fR\|(1)
